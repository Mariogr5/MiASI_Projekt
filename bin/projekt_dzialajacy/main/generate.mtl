[module generate('http://www.eclipse.org/uml2/5.0.0/UML')]

[query public toScreamingSnakeCase(input : String) : String =
	if (input.trim() = '') then
        ''
    else
        let cleanedInput : String = input.trim().replaceAll(' {1,}', '_').replaceAll('_{2,}', '_') in
        let words : Sequence(String) = 
            if (cleanedInput.contains('_')) then
                cleanedInput.tokenize('_')->select(w | w <> '')
            else
                cleanedInput->collect(c | 
                    if (c.toString().toUpperCase() = c.toString() and c.toString().matches('[A-Z]')) then
                        '_' + c.toString()
                    else
                        c.toString()
                    endif
                )->toString().replaceAll('([a-z])([A-Z])', '$1_$2').tokenize('_')->select(w | w <> '')
            endif
        in
        if (words->isEmpty()) then
            ''
        else
            words->collect(w | w.toUpperCase())->sep('_')
        endif
    endif	
/]

[query public toCamelCase(input : String) : String =
	if (input.trim() = '') then
		''
	else
		let cleanedInput : String = input.trim().replaceAll(' {1,}', '_').replaceAll('_{2,}', '_') in
		let words : Sequence(String) = cleanedInput.tokenize('_')->select(w | not w.oclIsUndefined() and w.trim() <> '') in
		if (words->isEmpty()) then
			input.trim().toLowerFirst()
		else
			let firstWord : String = words->first().toLowerFirst() in
			let otherWords : Sequence(String) = words->subSequence(2, words->size()) in
			firstWord +
			otherWords->collect(word |
				if (word.size() > 0) then
					word.substring(1,1).toUpperCase() +
					word.substring(2, word.size()).toLower()
				else
					''
				endif
			)->sep('')
		endif
	endif
/]

[query public parseExpression(expr : OpaqueExpression) : Sequence(String) =
	if (expr._body->first().trim() = '') then
        Sequence{}
	else
	    let cleanedExpr : String = expr._body->first().trim() in
	    let operators : Sequence(String) = Sequence{'==', '!=', '>=', '<=', '>', '<'} in
	    let matchedOperator : String = operators->select(op | cleanedExpr.contains(op))->first() in
	    if (matchedOperator <> null and cleanedExpr.tokenize(matchedOperator)->size() = 2) then
	        let parts : Sequence(String) = cleanedExpr.tokenize(matchedOperator) in
	        let param : String = parts->first().trim() in
	        let val : String = parts->at(2).trim() in
	        if (param <> '' and val <> '') then
	            Sequence{param, matchedOperator, val}
	        else
	            Sequence{}
	        endif
	    else
	        Sequence{}
	    endif
	endif
/]

[comment @main/]
[template public generateElement(stateMachine : StateMachine)]

[comment @main/]
[file ('State.hpp', false, 'UTF-8')]
#pragma once
#include <memory>

class Context;

class State {
public:
    virtual ~State() = default;
    virtual void enter(Context& context) = 0;
    virtual void doActivity(Context& context) = 0;
    virtual void exit(Context& context) = 0;
    virtual const char* name() const = 0;
};
[/file]

[comment @main/]
[file ('Event.hpp', false, 'UTF-8')]
#pragma once

public enum class Event {
	NONE_EVENT,
	[for (event: Event | Model.allInstances()->collect(e | e.packagedElement)->flatten()
		->filter(uml::Event)->select(e | e.name <> '')
	)]
	[event.eClass().name.toScreamingSnakeCase()/]_[event.name.toScreamingSnakeCase()/],
	[/for]
};

[/file]

[comment @main/]
[file ('Context.hpp', false, 'UTF-8')]
#pragma once
#include <memory>
#include <iostream>
#include <chrono>
#include "State.hpp"

class Context {
private:
    std::unique_ptr<State> currentState;
    std::chrono::steady_clock::time_point stateStartTime;

    bool missing_configuration = false;
    bool firmware_update_avaiable = false;

public:
    Context(std::unique_ptr<State> initialState)
        : currentState(std::move(initialState)), stateStartTime(std::chrono::steady_clock::now()) {}

    void setState(std::unique_ptr<State> newState) {
        currentState = std::move(newState);
        stateStartTime = std::chrono::steady_clock::now();
    }

    void printState() const {
        std::cout << "Current state: " << currentState->name() << std::endl;
    }

    bool get_missing_configuration() const { return missing_configuration; }
    void set_missing_configuration(bool val) { missing_configuration = val; }

    bool get_firmware_update_available() const { return firmware_update_avaiable; }
    void set_firmware_update_available(bool val) { firmware_update_avaiable = val; }

    bool isTimeElapsed(int milliseconds) const {
        auto now = std::chrono::steady_clock::now();
        return std::chrono::duration_cast<std::chrono::milliseconds>(now - stateStartTime).count() >= milliseconds;
    }
};
[/file]

[comment @main/]
[file ('Transition.hpp', false, 'UTF-8')]
#pragma once
#include "Context.hpp"
#include "Event.hpp"
#include "State.hpp"

class Transition {
public:
	State *from;
	State *to;
	Event trigger;
	bool (*guard)(Context&);
	void (*activity)(Context&);
	
	~Transition() = default;
	Transition(State *_from, State *_to, Event _trigger = Event::NONE_EVENT, bool (*_guard)(Context&) = nullptr), void (*_activity(Context&) = nullptr
        : from(_from), to(_to), trigger(_trigger), guard(_guard), activity(_activity) {}
};
[/file]

[comment @main/]
[file ('Guard.hpp', false, 'UTF-8')]
#include "Context.hpp"

namespace Guard {
	[for (constraint : Constraint | stateMachine.region->collect(r | r.transition)->flatten()
    	->collect(t | t.ownedRule)->flatten()
	)]
	[let parts: Sequence(String) = constraint->collect(c | c.specification)->flatten()
		->filter(OpaqueExpression)->asSequence()->first().parseExpression()
	]
	[if (parts->size() > 1)]
	bool [constraint.name.toCamelCase()/](Context& ctx) { return ctx.[Sequence{parts->at(1).toCamelCase(), parts->at(2), parts->at(3)}->sep(' ')/]; }
	[/if]
	[/let]
	[/for]
};

[/file]

[for (state : State | stateMachine.region->collect(r | r.subvertex)->flatten()->filter(uml::State))]

[comment @main/]
[file (state.name.concat('.hpp'), false, 'UTF-8')]
#pragma once
#include "State.hpp"
#include "Context.hpp"
[for (target : NamedElement | state.outgoing->collect(t | t.target)->asSet())]
#include "[target.name/].hpp"
[/for]

[if (not state.ownedComment->isEmpty())]
// [state.ownedComment->asSequence()->first()._body/]
[/if]
class [state.name/] : public State {
public:
    void enter(Context& ctx) override;
    void doActivity(Context& ctx) override;
    void exit(Context& ctx) override;
    void transition(Context& ctx) override;
    const char* name() const override;

private:
[if (not state.entry->isEmpty() and not state.entry.name.oclIsUndefined())]
    void [state.entry.name/](Context& context);
[/if]
[if (not state.doActivity->isEmpty() and not state.doActivity.name.oclIsUndefined())]
    void [state.doActivity.name/](Context& context);
[/if]
[if (not state.exit->isEmpty() and not state.exit.name.oclIsUndefined())]
    void [state.exit.name/](Context& context);
[/if]
[for (t : Transition | state.outgoing->filter(Transition)->select(g | g.guard->notEmpty()))]
    [if (not t.guard.ownedComment->isEmpty())]
    // [t.guard.ownedComment->asSequence()->first()._body/]
    [/if]
    bool [t.guard.name/](Context& context);
[/for]
[for (t : Transition | state.outgoing->filter(Transition)->select(e | e.effect->notEmpty()))]
    [if (not t.effect->asSequence()->first().ownedComment->isEmpty())]
    // [t.effect->asSequence()->first().ownedComment->asSequence()->first()._body/]
    [/if]
    void [t.effect->asSequence()->first().name/](Context& context);
[/for]
};
[/file]

[comment @main/]
[file (state.name.concat('.cpp'), false, 'UTF-8')]
#include "[state.name/].hpp"
#include <iostream>

void [state.name/]::enter(Context& context) {
    std::cout << "Entering state: [state.name/]" << std::endl;
    [if (not state.entry->isEmpty() and not state.entry.name.oclIsUndefined())]
    [state.entry.name/](context);
    [/if]
}

void [state.name/]::doActivity(Context& context) {
    std::cout << "Executing activity in state: [state.name/]" << std::endl;
    [if (not state.doActivity->isEmpty() and not state.doActivity.name.oclIsUndefined())]
    [state.doActivity.name/](context);
    [/if]
}

void [state.name/]::exit(Context& context) {
    std::cout << "Exiting state: [state.name/]" << std::endl;
    [if (not state.exit->isEmpty() and not state.exit.name.oclIsUndefined())]
    [state.exit.name/](context);
    [/if]
}

void [state.name/]::transition(Context& context) {
[let transitions : Sequence(Transition) = state.outgoing->filter(Transition)->asSequence()]
[for (t : Transition | transitions)]
[for (trigger : Trigger | t.trigger)]
    std::cout << "Event: [trigger.name/]" << std::endl;
[/for]
    [if (t.guard->notEmpty())]
    [if (not t.ownedComment->isEmpty())]
    // [t.ownedComment->asSequence()->first()._body/]
    [/if]
    if ([t.guard.name/](context)) {
    	[if (t.effect->notEmpty())]
    	[t.effect->asSequence()->first().name/](context);
    [/if]
	    context.setState(std::make_unique<[t.target.name/]>());
	    return;
    }
    [else]
    [if (not t.ownedComment->isEmpty())]
    // [t.ownedComment->asSequence()->first()._body/]
    [/if]
    [if (t.effect->notEmpty())]
    	effect_[t.target.name/](context);
	    context.setState(std::make_unique<[t.target.name/]>());
	    return;
	[else]
    context.setState(std::make_unique<[t.target.name/]>());
    return;
    [/if]
    [/if]
[/for]
[/let]
    std::cout << "No valid transition from state: [state.name/]" << std::endl;
}

const char* [state.name/]::name() const {
    return "[state.name/]";
}

[if (not state.entry->isEmpty() and not state.entry.name.oclIsUndefined())]
void [state.name/]::[state.entry.name/](Context& context) {
    std::cout << "Executing [state.entry.name/]" << std::endl;
}
[/if]
[if (not state.doActivity->isEmpty() and not state.doActivity.name.oclIsUndefined())]
void [state.name/]::[state.doActivity.name/](Context& context) {
    std::cout << "Executing [state.doActivity.name/]" << std::endl;
}
[/if]
[if (not state.exit->isEmpty() and not state.exit.name.oclIsUndefined())]
void [state.name/]::[state.exit.name/](Context& context) {
    std::cout << "Executing [state.exit.name/]" << std::endl;
}
[/if]

[for (t : Transition | state.outgoing->filter(Transition)->select(g | g.guard->notEmpty()))]
bool [state.name/]::[t.guard.name/](Context& context) {
    return context.get_[t.guard.specification.oclAsType(OpaqueExpression)._body->first().replaceAll('==', '() == ')/];
}
[/for]

[for (t : Transition | state.outgoing->filter(Transition)->select(e | e.effect->notEmpty()))]
void [state.name/]::[t.effect->asSequence()->first().name/](Context& context) {
    std::cout << "Executing effect [t.effect->asSequence()->first().name/]" << std::endl;
}
[/for]
[/file]

[/for]

[/template]
